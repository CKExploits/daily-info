# 互联网安全 推荐
| ts | title | url| 
| --- | --- | ---| 


# 玄武实验室 推荐
| ts | title | url| 
| --- | --- | ---| 
| 20220403 | IETF 113线上会议资料。 | https://theinternetprotocolblog.wordpress.com/2022/03/30/ietf-113/| 
| 20220403 | 潜藏在风平浪静中的波澜——APT-C-00海莲花组织攻击活动动态浅析 | https://mp.weixin.qq.com/s/tBQSbv55lJUipaPWFr1fKw| 
| 20220402 | Rockwell PLC 被发现远程高危漏洞 | https://thehackernews.com/2022/04/critical-bugs-in-rockwell-plc-could.html| 
| 20220402 | Linux 内核 netfilter 子系统 nf_tables CVE-2022-1015/CVE-2022-1016 漏洞分析 | https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/| 
| 20220402 | On the Naturalness of Fuzzer-Generated Code | http://rohan.padhye.org/files/natfuzz-msr22.pdf| 
| 20220402 | Microsoft Defender for Endpoint 的调试方法以及身份伪造漏洞分析 | https://medium.com/falconforce/debugging-the-undebuggable-and-finding-a-cve-in-microsoft-defender-for-endpoint-ce36f50bb31| 
| 20220402 | Go 语言将应用新 Mitigation 防御供应链攻击 | https://go.dev/blog/supply-chain| 
| 20220402 | PHP Supply Chain Attack on PEAR | https://blog.sonarsource.com/php-supply-chain-attack-on-pear/| 
| 20220402 | 用于测试 SSH 中间人劫持的工具 | https://github.com/ssh-mitm/ssh-mitm/blob/master/README.md| 
| 20220402 | Austin Pwn2Own 比赛利用 4 个漏洞实现 Cisco RV340 RCE 的细节 | https://blog.relyze.com/2022/04/pwning-cisco-rv340-with-4-bug-chain.html| 
| 20220402 | 基于符号执行技术的二进制漏洞挖掘 | https://docs.google.com/presentation/d/1E3uE-4mYpenw0s40rtMbIdxj3fJgC79aHCeiIlJSY5Y/edit| 
| 20220401 | 损失超 6.1 亿美元 —— Ronin Network 被黑分析 | https://mp.weixin.qq.com/s/0U58Chw970X2GWcj2fvLPg| 
| 20220401 | 基于 Angr 的控制流反混淆 | http://research.openanalysis.net/angr/symbolic%20execution/deobfuscation/research/2022/03/26/angr_notes.html| 
| 20220401 | Evernote 被发现 SSRF 漏洞 | http://blog.neolex.dev/13/| 
| 20220401 | NETGEAR R6700v3 upnpd CVE-2022-27643 RCE 漏洞分析 | https://blog.relyze.com/2022/03/cve-2022-27643-netgear-r6700v3-upnpd.html| 
| 20220401 | Spring 官方发表关于近期 RCE 漏洞的声明 | https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement| 
| 20220401 | Apple 发布紧急补丁，修复两个已出现野外利用的漏洞 | https://support.apple.com/zh-cn/HT213220| 
| 20220401 | Project Zero 公开了 iOS FORCEDENTRY 利用链的沙箱逃逸部分的分析 | https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html| 
| 20220401 | 多个 APT 组织趁着俄乌乱局的掩护发起针对其他目标的攻击 | http://research.checkpoint.com/2022/state-sponsored-attack-groups-capitalise-on-russia-ukraine-war-for-cyber-espionage/| 
| 20220401 | 【Rootkit 系列研究】Windows 平台的高隐匿、高持久化威胁 | https://paper.seebug.org/1868/| 


# 安全维基 推荐
| ts | title | url| 
| --- | --- | ---| 
| 20220404 | SecWiki周刊（第422期) | https://www.sec-wiki.com/weekly/422| 
| 20220404 | CDN及特征隐匿Cobalt Strike | https://xz.aliyun.com/t/11099| 
| 20220404 | 对于挖矿的检测以及防御方案 | https://xz.aliyun.com/t/11102| 
| 20220404 | Generate all call graph for Java Code | https://github.com/Adrninistrator/java-all-call-graph| 
| 20220403 | 从DARPA项目学习如何做安全研究 | https://mp.weixin.qq.com/s/BkOIosI50NRqzz8Vsbm1Hg| 
| 20220403 | 欺骗Wappalyzer插件指纹识别 | https://blog.xlab.app/p/63a5b7e6/| 
| 20220402 | 加密数字货币合约交易的匿名性保护与对抗 | https://mp.weixin.qq.com/s/_QWBvf-zH_urvswRwpInaw| 
| 20220402 | XNU虚拟内存安全往事 | https://mp.weixin.qq.com/s/Lj8c5PLzLGIfdBoDzairsQ| 
| 20220402 | 安全快报 , 美国提出新法案，加强医疗保健和公共卫生部门网络... | https://mp.weixin.qq.com/s/2rTm5bRByYjreyxWcO4b7Q| 
| 20220402 | 安全周报1 , 国际红十字会遭受网络攻击，万人数据信息惨遭泄露 | https://mp.weixin.qq.com/s/tSOChrrLqfwi2IA4akWgnQ| 


# CVE Github 推荐
| ts | cve_id | title | url | cve_detail| 
| --- | --- | --- | --- | ---| 
| 20220405T12:11:32Z | CVE-2022-25636 | CVE-2022-25636 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2022-25636-PipeVersion | | 
| 20220405T11:33:14Z | CVE-2022-22639 | Exploitation of CVE-2022-22639 | https://github.com/jhftss/CVE-2022-22639 | | 
| 20220405T11:26:16Z | CVE-2022-0185 | CVE-2022-0185 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2022-0185-PipeVersion | | 
| 20220405T11:23:52Z | CVE-2021-22555 | CVE-2021-22555 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2021-22555-PipeVersion | | 
| 20220405T11:20:31Z | CVE-2022-22947 | CVE-2022-22947 reproduce | https://github.com/aesm1p/CVE-2022-22947-POC-Reproduce | | 
| 20220405T08:56:16Z | CVE-2022-22963 | Null | https://github.com/darryk10/CVE-2022-22963 | | 
| 20220405T08:34:27Z | CVE-2020-24186 | CVE-2020-24186的攻击脚本 | https://github.com/Sakura-501/CVE-2020-24186-exploit | | 
| 20220405T02:59:59Z | CVE-2022-22965 | A Safer PoC for CVE-2022-22965 (Spring4Shell) | https://github.com/colincowie/Safer_PoC_CVE-2022-22965 | | 
| 20220404T21:33:51Z | CVE-2021-40438 | Apache forward request CVE | https://github.com/Kashkovsky/CVE-2021-40438 | | 
| 20220404T21:09:58Z | CVE-2022-22965 | Another spring4shell (Spring core RCE)  POC | https://github.com/netcode/Spring4shell-CVE-2022-22965-POC | | 


# klee on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T11:39:45Z | Imagine you could pick up a fragment of code in a complex system written in C and test it in separation on your Linux workstation without the burden of including all necessary headers and knowing the right set of #defines, compilation flags and the target architecture. Imagine you could use that code in a modern fuzzer or symbolic execution engine for thorough, focused deep testing.  AoT makes it possible to select a function from C code base and generate an executable off-target test harness. The harness can then be tested on a Linux machine, e.g. with ASAN, AFL or KLEE. The generated off-target is a self-contained binary and includes all the necessary types and definitions. In a nutshell, AoT makes it possible to test pieces of complex systems software in a unit test-like manner. What it is and how does this work?  First, you select a function F you are interested to test. AoT uses Code Aware Services (CAS) infrastructure, namely code database and compilation database to automatically pull in a subtree of functions called by F (that is, functions that F calls, functions that they call, etc.). By default, AoT stops at the module boundary: the functions compiled into the same module as F are pulled in, all the others are left out. For the functions that are left out AoT generates function stubs which can later be filled by the user. Such generated program is called an off-target, because it runs off the original code execution environment (e.g. a smartphone).  AoT works well with the AFL fuzzer (https://lcamtuf.coredump.cx/afl/) and the KLEE symbolic execution engine (http://klee.github.io/). It automatically generates binaries and test setup for those tools, so that you can start fuzzing the off-target immediately.  AoT is an automated solution that currently works in the human-in-the-loop model. It means that AoT tries to automate as much as possible, but a human operator is needed to fine-tune the results - e.g. provide stubs implementation or correct the program state initialization.  Potential uses of AoT are:      get a recursive list of functions given an entry point (could be used to get selective coverage)     get a list of types necessary for a given piece of code     instrument code for inter-structure fuzzing (unsupported yet)     instrument code for fuzzing / symbolic execution and apply those techiques to complex systems code     speed up development for slowly building targets (e.g. AOSP build process)  For example, let%s imagine we would like to test a message parser in a mobile phone modem. Normally, for such testing we need to set up the physical infrastructure, for example a base station that sends messages over the air to the mobile phone. When the message is received by the phone, the parser code is invoked. If there is an error, we need to collect potential crash logs (if any) and restart testing. The whole process is difficult to set up and a single testing cycle takes quite long. With AoT things look differently. We select the message parsing function as our target. AoT automatically pulls in the necessary definitions and functions compiled into the same module and generates function stubs for the functions outside of the module. Moreover, AoT generates the program state initialization and the code necessary for starting security fuzzing. The generated off-target code is self contained - we can compile it on a Linux box and use all standard tools such as fuzzers, gdb, sanitizers to test the code. As a result, we end up with a much faster setup and test cycle: the off-target generation takes minutes and we can re-execute the code up to thousands of times per minute. We can also easily attach a debugger and quickly inspect what went wrong.  As a further example let%s take the last point and let%s imagine we are modifying an AOSP kernel driver. Without AoT, we need to invoke entire build process to check if our change is correct. Moreover, we would need to run the code in an Android emulator or on the phone and find a way to invoke the changed driver code (which sometimes is not trivial). With AoT we can extract the code of the changed function and compile it within minutes. We can further use all available x86_64 Linux toolchains (gdb, sanitizers, etc.) to test it. As a result, the development & testing cycle should be much shorter. | https://github.com/Samsung/auto_off_target | 1 | 0| 
| 20220405T10:12:20Z | An open-source Chinese font derived from Fontworks% Klee One. 一款开源中文字体，基于 FONTWORKS 出品字体 Klee One 衍生。   | https://github.com/lxgw/LxgwWenKai | 5665 | 209| 
| 20220405T08:38:50Z | A concolic testing framework for RISC-V embedded software with support for SystemC peripherals | https://github.com/agra-uni-bremen/symex-vp | 6 | 1| 
| 20220405T06:06:08Z | KLEE Symbolic Execution Engine | https://github.com/klee/klee | 1931 | 550| 
| 20220404T10:03:24Z | Null | https://github.com/beardlessPaul/klee-v.2.1 | 0 | 0| 
| 20220402T17:20:28Z | Null | https://github.com/mishra-kunal1/Klee-Project | 1 | 1| 
| 20220401T19:54:17Z | Null | https://github.com/220328-Java-Full-Stack-AWS/Jack-Klees-P1 | 0 | 0| 
| 20220401T12:56:28Z | Collection of Kicad 6.0 symbols, footprints and 3D models useful in keyboard creation | https://github.com/crides/kleeb | 17 | 0| 
| 20220401T09:47:13Z | Null | https://github.com/paperplanefactory/kleecks-wp-theme | 0 | 0| 
| 20220401T04:40:16Z | Null | https://github.com/cheehieu/kleenex-shoes | 0 | 0| 


# s2e on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220403T15:27:07Z | Null | https://github.com/wqewqfdas/s2edsa | 0 | 0| 
| 20220403T10:01:51Z | Null | https://github.com/s2eung1/s2eung1 | 0 | 0| 
| 20220402T21:47:27Z | Documents for Spacecraft Simulation Environment | https://github.com/ut-issl/s2e-documents | 3 | 3| 
| 20220402T17:57:18Z | Null | https://github.com/software-testing-bootcamp/S2E4-API-Test-Karate-Gatling | 0 | 0| 


# exploit on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T12:11:32Z | CVE-2022-25636 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2022-25636-PipeVersion | 3 | 1| 
| 20220405T11:57:51Z | An exploit primitive in linux kernel inspired by DirtyPipe | https://github.com/veritas501/pipe-primitive | 7 | 1| 
| 20220405T11:26:16Z | CVE-2022-0185 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2022-0185-PipeVersion | 1 | 1| 
| 20220405T11:23:52Z | CVE-2021-22555 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2021-22555-PipeVersion | 5 | 1| 
| 20220405T10:54:49Z | Gather and update all available and newest CVEs with their PoC. | https://github.com/trickest/cve | 2576 | 315| 
| 20220405T10:35:08Z | the ultimate exploits/references finder | https://github.com/ARPSyndicate/xlocate | 26 | 5| 
| 20220405T10:16:05Z | This repository is primarily maintained by Omar Santos and includes thousands of resources related to ethical hacking  / penetration testing, digital forensics and incident response (DFIR), vulnerability research, exploit development, reverse engineering, and more. | https://github.com/The-Art-of-Hacking/h4cker | 10963 | 1918| 
| 20220405T09:36:16Z | Search through Microsoft Security Bulletins (MSSB%s) to find relevant vulnerabilities and exploits to use against Windows target machines. | https://github.com/glowbase/windows-exploit-search | 0 | 0| 
| 20220405T09:00:47Z | Null | https://github.com/1337-L3V1ATH0N/OSCP-Win-Exploits | 0 | 0| 
| 20220405T08:49:32Z | 黑客工具收集仓库，包含主流和非主流漏洞利用工具，subdomain、备案查询工具、CVE仓库、Hacking Tools、Exploits、免杀工具、weblogic漏洞利用工具、Red Team、Cobalt Strike、C免杀、bypassAV、内网渗透工具、漏洞利用、工具插件、burpsuite插件； | https://github.com/CnHack3r/Awesome-hacking-tools | 47 | 8| 


# backdoor on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T12:43:26Z | Linux eBPF backdoor over TCP. Spawn reverse shells, RCE, on prior privileged access. Less Honkin, More Tonkin. | https://github.com/kris-nova/boopkit | 310 | 27| 
| 20220405T12:26:04Z | Windows backdoor that will be registered and melted to the registry and embedded to the startup and is scanned to undetectable by 32 anti-virus :p  | https://github.com/NetM0nDevs/Winddows-Backdoor-B- | 0 | 0| 
| 20220405T08:22:16Z | Config files for my GitHub profile. | https://github.com/backdoorPhish/backdoorPhish | 0 | 0| 
| 20220405T06:46:12Z | A curated list of backdoor learning resources | https://github.com/THUYimingLi/backdoor-learning-resources | 453 | 87| 
| 20220404T15:37:56Z | This contains two python programmes | https://github.com/thepolkamonster/Backdoor | 0 | 0| 
| 20220404T05:31:46Z | Null | https://github.com/039710/Example-Backdoor | 0 | 0| 
| 20220403T16:42:05Z | AMWScan (PHP Antimalware Scanner) is a free tool to scan php files and analyze your project to find any malicious code inside it. | https://github.com/marcocesarato/PHP-Antimalware-Scanner | 313 | 54| 
| 20220403T16:07:21Z | Tool to create fileless Discord remote access trojans | https://github.com/cchash/DiscoShell | 1 | 1| 
| 20220403T15:36:16Z | Backdoor injector for Bukkit/Spigot plugins. | https://github.com/HastG99/MinePatcher | 2 | 0| 
| 20220403T12:20:17Z | Linux eBPF backdoor (TCP/UDP) for spawning reverse shells. Less Honkin. More Tonkin.  | https://github.com/kris-nova/ENOHONK | 6 | 0| 


# symbolic execution on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T12:45:37Z | Imagine you could pick up a fragment of code in a complex system written in C and test it in separation on your Linux workstation without the burden of including all necessary headers and knowing the right set of #defines, compilation flags and the target architecture. Imagine you could use that code in a modern fuzzer or symbolic execution engine for thorough, focused deep testing.  AoT makes it possible to select a function from C code base and generate an executable off-target test harness. The harness can then be tested on a Linux machine, e.g. with ASAN, AFL or KLEE. The generated off-target is a self-contained binary and includes all the necessary types and definitions. In a nutshell, AoT makes it possible to test pieces of complex systems software in a unit test-like manner. What it is and how does this work?  First, you select a function F you are interested to test. AoT uses Code Aware Services (CAS) infrastructure, namely code database and compilation database to automatically pull in a subtree of functions called by F (that is, functions that F calls, functions that they call, etc.). By default, AoT stops at the module boundary: the functions compiled into the same module as F are pulled in, all the others are left out. For the functions that are left out AoT generates function stubs which can later be filled by the user. Such generated program is called an off-target, because it runs off the original code execution environment (e.g. a smartphone).  AoT works well with the AFL fuzzer (https://lcamtuf.coredump.cx/afl/) and the KLEE symbolic execution engine (http://klee.github.io/). It automatically generates binaries and test setup for those tools, so that you can start fuzzing the off-target immediately.  AoT is an automated solution that currently works in the human-in-the-loop model. It means that AoT tries to automate as much as possible, but a human operator is needed to fine-tune the results - e.g. provide stubs implementation or correct the program state initialization.  Potential uses of AoT are:      get a recursive list of functions given an entry point (could be used to get selective coverage)     get a list of types necessary for a given piece of code     instrument code for inter-structure fuzzing (unsupported yet)     instrument code for fuzzing / symbolic execution and apply those techiques to complex systems code     speed up development for slowly building targets (e.g. AOSP build process)  For example, let%s imagine we would like to test a message parser in a mobile phone modem. Normally, for such testing we need to set up the physical infrastructure, for example a base station that sends messages over the air to the mobile phone. When the message is received by the phone, the parser code is invoked. If there is an error, we need to collect potential crash logs (if any) and restart testing. The whole process is difficult to set up and a single testing cycle takes quite long. With AoT things look differently. We select the message parsing function as our target. AoT automatically pulls in the necessary definitions and functions compiled into the same module and generates function stubs for the functions outside of the module. Moreover, AoT generates the program state initialization and the code necessary for starting security fuzzing. The generated off-target code is self contained - we can compile it on a Linux box and use all standard tools such as fuzzers, gdb, sanitizers to test the code. As a result, we end up with a much faster setup and test cycle: the off-target generation takes minutes and we can re-execute the code up to thousands of times per minute. We can also easily attach a debugger and quickly inspect what went wrong.  As a further example let%s take the last point and let%s imagine we are modifying an AOSP kernel driver. Without AoT, we need to invoke entire build process to check if our change is correct. Moreover, we would need to run the code in an Android emulator or on the phone and find a way to invoke the changed driver code (which sometimes is not trivial). With AoT we can extract the code of the changed function and compile it within minutes. We can further use all available x86_64 Linux toolchains (gdb, sanitizers, etc.) to test it. As a result, the development & testing cycle should be much shorter. | https://github.com/Samsung/auto_off_target | 1 | 0| 
| 20220405T09:45:46Z | Angora is a mutation-based fuzzer.  The main goal of Angora is to increase branch coverage by solving path constraints without symbolic execution.  | https://github.com/AngoraFuzzer/Angora | 769 | 146| 
| 20220405T06:58:53Z | Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM. | https://github.com/JonathanSalwan/VMProtect-devirtualization | 530 | 94| 
| 20220405T06:06:08Z | KLEE Symbolic Execution Engine | https://github.com/klee/klee | 1931 | 550| 
| 20220404T16:06:36Z | Symbolic-execution-based verifier for the Viper intermediate verification language. | https://github.com/viperproject/silicon | 29 | 18| 
| 20220404T15:09:38Z | Slides and Material for %SymbolicExecutionDemystified% Presentation @ Insomni%Hack 2022 | https://github.com/JannisKirschner/SymbolicExecutionDemystified | 83 | 14| 
| 20220404T14:20:42Z | A symbolic execution engine for LLVM IR | https://github.com/insufficiently-caffeinated/caffeine | 16 | 5| 
| 20220402T19:53:34Z | We have to perform the verification of the partial or total correctness of two algorithms. | https://github.com/marc7666/Verification-of-Programs-with-Hoare-Logic-and-Symbolic-Execution | 0 | 0| 
| 20220401T16:45:37Z | radius2 is a fast binary emulation and symbolic execution framework using radare2 | https://github.com/aemmitt-ns/radius | 214 | 15| 


# big4 on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T05:38:58Z | Code for NDSS 2022 paper %MIRROR: Model Inversion for Deep Learning Network with High Fidelity% | https://github.com/njuaplusplus/mirror | 2 | 0| 


# fuzz on Github 推荐
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220405T12:45:37Z | Imagine you could pick up a fragment of code in a complex system written in C and test it in separation on your Linux workstation without the burden of including all necessary headers and knowing the right set of #defines, compilation flags and the target architecture. Imagine you could use that code in a modern fuzzer or symbolic execution engine for thorough, focused deep testing.  AoT makes it possible to select a function from C code base and generate an executable off-target test harness. The harness can then be tested on a Linux machine, e.g. with ASAN, AFL or KLEE. The generated off-target is a self-contained binary and includes all the necessary types and definitions. In a nutshell, AoT makes it possible to test pieces of complex systems software in a unit test-like manner. What it is and how does this work?  First, you select a function F you are interested to test. AoT uses Code Aware Services (CAS) infrastructure, namely code database and compilation database to automatically pull in a subtree of functions called by F (that is, functions that F calls, functions that they call, etc.). By default, AoT stops at the module boundary: the functions compiled into the same module as F are pulled in, all the others are left out. For the functions that are left out AoT generates function stubs which can later be filled by the user. Such generated program is called an off-target, because it runs off the original code execution environment (e.g. a smartphone).  AoT works well with the AFL fuzzer (https://lcamtuf.coredump.cx/afl/) and the KLEE symbolic execution engine (http://klee.github.io/). It automatically generates binaries and test setup for those tools, so that you can start fuzzing the off-target immediately.  AoT is an automated solution that currently works in the human-in-the-loop model. It means that AoT tries to automate as much as possible, but a human operator is needed to fine-tune the results - e.g. provide stubs implementation or correct the program state initialization.  Potential uses of AoT are:      get a recursive list of functions given an entry point (could be used to get selective coverage)     get a list of types necessary for a given piece of code     instrument code for inter-structure fuzzing (unsupported yet)     instrument code for fuzzing / symbolic execution and apply those techiques to complex systems code     speed up development for slowly building targets (e.g. AOSP build process)  For example, let%s imagine we would like to test a message parser in a mobile phone modem. Normally, for such testing we need to set up the physical infrastructure, for example a base station that sends messages over the air to the mobile phone. When the message is received by the phone, the parser code is invoked. If there is an error, we need to collect potential crash logs (if any) and restart testing. The whole process is difficult to set up and a single testing cycle takes quite long. With AoT things look differently. We select the message parsing function as our target. AoT automatically pulls in the necessary definitions and functions compiled into the same module and generates function stubs for the functions outside of the module. Moreover, AoT generates the program state initialization and the code necessary for starting security fuzzing. The generated off-target code is self contained - we can compile it on a Linux box and use all standard tools such as fuzzers, gdb, sanitizers to test the code. As a result, we end up with a much faster setup and test cycle: the off-target generation takes minutes and we can re-execute the code up to thousands of times per minute. We can also easily attach a debugger and quickly inspect what went wrong.  As a further example let%s take the last point and let%s imagine we are modifying an AOSP kernel driver. Without AoT, we need to invoke entire build process to check if our change is correct. Moreover, we would need to run the code in an Android emulator or on the phone and find a way to invoke the changed driver code (which sometimes is not trivial). With AoT we can extract the code of the changed function and compile it within minutes. We can further use all available x86_64 Linux toolchains (gdb, sanitizers, etc.) to test it. As a result, the development & testing cycle should be much shorter. | https://github.com/Samsung/auto_off_target | 1 | 0| 
| 20220405T12:13:41Z | Null | https://github.com/AtaturkUniversity-MSc/FuzzyLogic | 0 | 0| 
| 20220405T12:10:01Z | Succotash has reminded me of Sylvester from the Looney Tunes cartoons and his famous catch phrase %Sufferin succotash% ever since I heard of this one pot wonder. This simple dish originated in New England, USA prior to becoming popular in the southern United States and it was also a common meal in the Depression era. Succotash is essentially a meal of corn and lima beans although there are variations aplenty with additions such as tomatoes, capsicums/bell peppers, okra, other types of beans, butter, margarine, lard, bacon, fresh and dried herbs.  With some freshly harvested broad beans (also known as fava beans) from the garden begging to be used and corn and okra in the fridge I decided to make a version of succotash. I didn%t follow a particular recipe, instead my broad beans, corn, okra and tomatoes were plonked into a pot and stirred every so often. It had been a long day labouring in the garden and we were tired and hungry so I didn%t bother with double peeling the broad beans to save on time. Finely chopped basil and parsley along with margarine and seasonings were stirred through in the final minute before serving. | https://github.com/estelaboots/fuzzy-succotash | 0 | 0| 
| 20220405T12:00:40Z | MSc  | https://github.com/isakulaksiz/FuzzyLogic | 0 | 0| 
| 20220405T11:19:13Z | Null | https://github.com/movhiwwwc/fuzzy-disco | 0 | 0| 
| 20220405T11:04:57Z | Classify data in ms sql server using fuzzy wuzzy. | https://github.com/yonadav-labs/fuzzy-data-classifier | 0 | 0| 
| 20220405T11:02:56Z | Null | https://github.com/RiswanBasha/ComVeh-Fuzz-Testing-Tool | 0 | 0| 
| 20220405T09:59:05Z | Null | https://github.com/dflehel/fuzzyuni | 0 | 0| 
| 20220405T09:49:01Z | Null | https://github.com/nonamesec/restler-fuzzer | 0 | 0| 
| 20220405T09:36:35Z | Null | https://github.com/SHIVANI0708/Fuzzy-College | 0 | 0| 



# 日更新程序
